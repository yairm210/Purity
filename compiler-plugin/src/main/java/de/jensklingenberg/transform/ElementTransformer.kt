package de.jensklingenberg.transform

import de.jensklingenberg.DebugLogger
import org.jetbrains.kotlin.backend.common.IrElementTransformerVoidWithContext
import org.jetbrains.kotlin.backend.common.extensions.IrPluginContext
import org.jetbrains.kotlin.cli.common.messages.CompilerMessageSeverity
import org.jetbrains.kotlin.cli.common.messages.MessageCollector
import org.jetbrains.kotlin.ir.IrElement
import org.jetbrains.kotlin.ir.IrStatement
import org.jetbrains.kotlin.ir.declarations.IrFunction
import org.jetbrains.kotlin.ir.declarations.IrSimpleFunction
import org.jetbrains.kotlin.ir.declarations.IrValueDeclaration
import org.jetbrains.kotlin.ir.declarations.IrVariable
import org.jetbrains.kotlin.ir.expressions.IrCall
import org.jetbrains.kotlin.ir.expressions.IrSetValue
import org.jetbrains.kotlin.ir.util.fileEntry
import org.jetbrains.kotlin.ir.util.getAnnotation
import org.jetbrains.kotlin.ir.util.getAnnotationArgumentValue
import org.jetbrains.kotlin.ir.visitors.IrElementVisitor
import org.jetbrains.kotlin.name.FqName

fun isMarkedAsPure(function: IrFunction): Boolean {
    // Marked by @Contract(pure = true)
    val pure = function.getAnnotationArgumentValue<Boolean>(FqName("org.jetbrains.annotations.Contract"), "pure")
    if (pure == true) return true

    // Simple values like int + int -> plus(int, int), are marked thus
    val constEvaluation = function.getAnnotation(FqName("kotlin.internal.IntrinsicConstEvaluation"))
    if (constEvaluation != null) return true

    return false
}


private fun userDisplayFileLocation(function: IrFunction, expression: IrElement): String {
    val location = function.fileEntry.getLineAndColumnNumbers(expression.startOffset)
    // Location we get is 0-indexed but we need the 1-indexed line and column for click-to-get-to-location
    val fileLocation = "file://${function.fileEntry.name}:${location.line + 1}:${location.column + 1}"
    return fileLocation
}

enum class FunctionColoring{
    None,
    Readonly,
    Pure
}

/** Warns every time a var is set a value, or an unpure function is called.
 * Vars that are created within the function are OK to set */
class CheckFunctionColoringVisitor(
    private val function: IrFunction,
    private val functionColoring: FunctionColoring,
    private val messageCollector: MessageCollector,
    
) : IrElementVisitor<Unit, Unit> { // Returns whether this is an acceptable X function
    var isReadonly = true
    var isPure = true

    // Iterate over IR tree and warn on each var set where the var is not created within this function
    @OptIn(org.jetbrains.kotlin.ir.symbols.UnsafeDuringIrConstructionAPI::class)
    override fun visitSetValue(expression: IrSetValue, data: Unit) {
        // Not sure if we can assume owner is set at this point :think:
        val varValueDeclaration: IrValueDeclaration = expression.symbol.owner
        if (varValueDeclaration is IrVariable && varValueDeclaration.isVar) {
            // Check if the variable is created in this function
            if (varValueDeclaration.parent != function) {
                val fileLocation = userDisplayFileLocation(function, expression)
                isReadonly = false
                isPure = false

                messageCollector.report(
                    CompilerMessageSeverity.WARNING,
                    "$fileLocation Function \"${function.name}\" is marked as $functionColoring but sets variable \"${varValueDeclaration.name}\""
                )
            }
        }
        super.visitSetValue(expression, data)
    }

    @OptIn(org.jetbrains.kotlin.ir.symbols.UnsafeDuringIrConstructionAPI::class)
    override fun visitCall(expression: IrCall, data: Unit) {
        // Only accept calls to functions marked as pure or readonly
        if (!isMarkedAsPure(expression.symbol.owner)) {
            val fileLocation = userDisplayFileLocation(function, expression)
            isPure = false
            isReadonly = false
            
            messageCollector.report(
                CompilerMessageSeverity.WARNING,
                "$fileLocation Function \"${function.name}\" is marked as $functionColoring " +
                        "but calls non-pure function \"${expression.symbol.owner.name}\""
            )
        }
        
        super.visitCall(expression, data) 
    }

    override fun visitElement(element: IrElement, data: Unit) {
        element.acceptChildren(this, data)
    }
}

internal class ElementTransformer(
    private val pluginContext: IrPluginContext,
    private val debugLogger: DebugLogger
) : IrElementTransformerVoidWithContext() {
    
    // These are created behind the scenes for every class, don't warn for them
    val autogeneratedFunctions = setOf(
        "<init>",
        "equals",
        "hashCode",
        "toString"
    )
    override fun visitSimpleFunction(declaration: IrSimpleFunction): IrStatement {
        if (isMarkedAsPure(declaration))
            declaration.accept(CheckFunctionColoringVisitor(declaration, FunctionColoring.Pure, debugLogger.messageCollector), Unit)
        else if (!autogeneratedFunctions.contains(declaration.name.asString())) {
            val visitor = CheckFunctionColoringVisitor(declaration, FunctionColoring.None, MessageCollector.NONE)
            declaration.accept(visitor, Unit)
            if (visitor.isPure) {
                val fileLocation = userDisplayFileLocation(declaration, declaration)
                debugLogger.messageCollector.report(
                    CompilerMessageSeverity.WARNING,
                    "$fileLocation Function \"${declaration.name}\" can be marked with @Contract(pure = true) to indicate it is pure."
                )
            }
        }
        
        return super.visitSimpleFunction(declaration)
    }

}