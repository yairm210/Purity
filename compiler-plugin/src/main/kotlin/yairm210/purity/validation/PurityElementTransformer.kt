package yairm210.purity.validation

import org.jetbrains.kotlin.backend.common.IrElementTransformerVoidWithContext
import org.jetbrains.kotlin.backend.common.extensions.IrPluginContext
import org.jetbrains.kotlin.cli.common.messages.CompilerMessageSeverity
import org.jetbrains.kotlin.cli.common.messages.MessageCollector
import org.jetbrains.kotlin.ir.IrStatement
import org.jetbrains.kotlin.ir.backend.js.utils.parentEnumClassOrNull
import org.jetbrains.kotlin.ir.backend.js.utils.valueArguments
import org.jetbrains.kotlin.ir.declarations.IrSimpleFunction
import org.jetbrains.kotlin.ir.expressions.IrConst
import org.jetbrains.kotlin.ir.expressions.impl.IrVarargImpl
import org.jetbrains.kotlin.ir.util.findAnnotation
import org.jetbrains.kotlin.ir.util.isInterface
import org.jetbrains.kotlin.ir.util.parentClassOrNull
import org.jetbrains.kotlin.name.FqName
import yairm210.purity.boilerplate.DebugLogger


internal class PurityElementTransformer(
    private val pluginContext: IrPluginContext,
    private val debugLogger: DebugLogger,
    private val wellKnownPureClassesFromUser: Set<String>,
    private val wellKnownPureFunctionsFromUser: Set<String>,
    private val wellKnownReadonlyFunctionsFromUser: Set<String>
) : IrElementTransformerVoidWithContext() {
    
    // These are created behind the scenes for every class, don't warn for them
    val autogeneratedFunctions = setOf(
        "equals",
        "hashCode",
        "toString"
    )
    val enumAutogeneratedFunctions = setOf(
        "values",
        "valueOf",
        "compareTo",
        "clone"
    )
    
    val componentRegex = "component\\d+".toRegex()
    
    fun isAutogeneratedFunction(function: IrSimpleFunction): Boolean {
        val name = function.name.asString()
        return autogeneratedFunctions.contains(name) 
                || name.startsWith('<') // auto-generated functions like <init>, <get-name>, <set-name>
                || function.parentEnumClassOrNull != null && (name in enumAutogeneratedFunctions) // Enum values function
                || function.parentClassOrNull?.isData == true && componentRegex.matches(name) // componentN functions for data classes
                || function.parentClassOrNull?.isData == true && name == "copy" // copy function for data classes

    }
    
    fun isSuppressed(declaration: IrSimpleFunction): Boolean {
        val suppressAnnotation = declaration.annotations.findAnnotation(FqName("kotlin.Suppress"))
            ?: return false
        
        // getAnnotationArgumentValue does not work for varargs, so we find the vararg
        //.flatmap{} instead of .valueArguments[0] because Suppress can be called with zero parameters also -_-
        @Suppress("UNCHECKED_CAST")
        val suppressParameters: List<String> = suppressAnnotation.valueArguments.flatMap { (it as IrVarargImpl).elements }
            .mapNotNull{it as? IrConst<String>}.map { it.value }

        return suppressParameters.contains("purity")
    }
    
    override fun visitSimpleFunction(declaration: IrSimpleFunction): IrStatement {
        if (isAutogeneratedFunction(declaration)) return super.visitSimpleFunction(declaration)
        
        // Skip interface/abstract functions that are not implemented
        if (declaration.body == null) return super.visitSimpleFunction(declaration)

        if (isSuppressed(declaration)) return super.visitSimpleFunction(declaration)

        val functionDeclaredColoring = when {
            PurityChecker.isMarkedAsPure(declaration, wellKnownPureClassesFromUser, wellKnownPureFunctionsFromUser) -> FunctionPurity.Pure
            PurityChecker.isReadonly(declaration, wellKnownReadonlyFunctionsFromUser) -> FunctionPurity.Readonly
            else -> FunctionPurity.None
        }
        val messageCollector = if (functionDeclaredColoring == FunctionPurity.None) MessageCollector.NONE 
        else debugLogger.messageCollector
        
        val visitor = CheckFunctionPurityVisitor(declaration, functionDeclaredColoring, messageCollector,
            wellKnownPureClassesFromUser,
            wellKnownPureFunctionsFromUser,
            wellKnownReadonlyFunctionsFromUser)
        declaration.accept(visitor, Unit)
        
        val actualColoring = visitor.actualFunctionColoring()
        if (functionDeclaredColoring != actualColoring){
            
            if (functionDeclaredColoring < actualColoring && 
                (isAutogeneratedFunction(declaration) // Don't warn for unmarked autogenerated functions - they are not under the user's control
                        || declaration.overriddenSymbols.any() // this is an override of another function
                        || declaration.parentClassOrNull?.isInterface == true
                        )
                ) {
                return super.visitSimpleFunction(declaration)
            }
            
            // if equal, no message; If less that declared, we already warn for each individual violation
            if (functionDeclaredColoring < actualColoring) {
                val message = when (actualColoring) {
                    FunctionPurity.Pure -> "Function \"${declaration.name}\" can be marked with @Contract(pure = true) to indicate it is pure"
                    FunctionPurity.Readonly -> "Function \"${declaration.name}\" can be marked with @Contract(\"readonly\") to indicate it is readonly"
                    else -> throw Exception("Unexpected function coloring: $actualColoring")
                }

                debugLogger.messageCollector.report(CompilerMessageSeverity.WARNING, message,
                    location = getLocationForExpression(declaration, declaration))
            }
        }
        
        return super.visitSimpleFunction(declaration)
    }

}