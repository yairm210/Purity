@file:OptIn(UnsafeDuringIrConstructionAPI::class)
package yairm210.purity.validation

import org.jetbrains.kotlin.ir.declarations.IrFunction
import org.jetbrains.kotlin.ir.declarations.IrSimpleFunction
import org.jetbrains.kotlin.ir.declarations.IrVariable
import org.jetbrains.kotlin.ir.expressions.IrConst
import org.jetbrains.kotlin.ir.expressions.IrGetValue
import org.jetbrains.kotlin.ir.expressions.IrReturn
import org.jetbrains.kotlin.ir.expressions.IrSyntheticBody
import org.jetbrains.kotlin.ir.symbols.UnsafeDuringIrConstructionAPI
import org.jetbrains.kotlin.ir.util.fqNameForIrSerialization
import org.jetbrains.kotlin.ir.util.getAnnotation
import org.jetbrains.kotlin.ir.util.getAnnotationArgumentValue
import org.jetbrains.kotlin.ir.util.statements
import org.jetbrains.kotlin.name.FqName
import yairm210.purity.PurityConfig

object PurityChecker {

    fun classMatches(function: IrFunction, wellKnownClasses: Set<String>): Boolean {
        val parentClassIdentifier = function.parent.fqNameForIrSerialization.asString()
        return parentClassIdentifier in wellKnownClasses
    }


    fun isMarkedAsPure(function: IrFunction, purityConfig: PurityConfig): Boolean {
        // Marked by @Contract(pure = true)
        val pure = function.getAnnotationArgumentValue<Boolean>(FqName("org.jetbrains.annotations.Contract"), "pure")
        if (pure == true) return true

        val fullyQualifiedClassName = function.parent.fqNameForIrSerialization.asString()
        if (fullyQualifiedClassName in wellKnownPureClasses) return true
        if (fullyQualifiedClassName in purityConfig.wellKnownPureClassesFromUser) return true

        val fullyQualifiedFunctionName = function.fqNameForIrSerialization.asString()
        if (fullyQualifiedFunctionName in wellKnownPureFunctions) return true
        if (fullyQualifiedFunctionName in purityConfig.wellKnownPureFunctionsFromUser) return true
        if (wellKnownPureFunctionsPrefixes.any { fullyQualifiedFunctionName.startsWith(it) }) return true

        // Simple values like int + int -> plus(int, int), are marked thus
        val constEvaluation = function.getAnnotation(FqName("kotlin.internal.IntrinsicConstEvaluation"))
        if (constEvaluation != null) return true

        if (isSingleStatementReturnPure(function)) return true

        return false
    }


    fun isReadonly(function: IrFunction, purityConfig: PurityConfig): Boolean {
        // Marked by @Contract(pure = true)
        val contractValue = function.getAnnotationArgumentValue<String>(FqName("org.jetbrains.annotations.Contract"), "value")
        if (contractValue == "readonly") return true

        if (function.name.asString().startsWith("<get-")) return true // Autogenerated function for classless variables

        val fullyQualifiedClassName = function.parent.fqNameForIrSerialization.asString()
        if (fullyQualifiedClassName in wellKnownReadonlyClasses) return true
        // TODO: Do we need user-inputted readonly classes?

        // Do NOT check for readonly parent classes - child classes can add non-readonly functionality!
        // E.g. List is readonly, but ArrayList is not.

        val fullyQualifiedFunctionName = function.fqNameForIrSerialization.asString()
        if (fullyQualifiedFunctionName in wellKnownReadonlyFunctions) return true
        if (fullyQualifiedFunctionName in purityConfig.wellKnownReadonlyFunctionsFromUser) return true

        // What is a NON-simple function, you ask? So do I! Lazy functions perhaps?
        if (function is IrSimpleFunction) {
            // Check if we're overriding a well-known readonly function
            for (overriddenFunction in getAllOverriddenFunctions(function).toSet()) {
                val overriddenFunctionName = overriddenFunction.fqNameForIrSerialization.asString()
                if (overriddenFunctionName in wellKnownReadonlyFunctions) return true
                if (overriddenFunctionName in purityConfig.wellKnownReadonlyFunctionsFromUser) return true
            }
        }

        if (isSingleStatementReturnReadonly(function)) return true

        return false
    }

    // overriddenSymbols only gives you the *direct* overrides, not the transitive ones.
    fun getAllOverriddenFunctions(function: IrSimpleFunction): Sequence<IrSimpleFunction> {
        return function.overriddenSymbols.asSequence()
            .flatMap {
                val owner = it.owner
                sequenceOf(owner) + getAllOverriddenFunctions(owner)
            }
    }

    /** For convenience - single-declaration functions like "fun getX() = x" are readonly */
    private fun isSingleStatementReturnReadonly(function: IrFunction): Boolean {
        val body = function.body ?: return false
        if (body is IrSyntheticBody) return false // Not sure what this IS, but it has no statements
        if (body.statements.size != 1) return false
        val statement = body.statements[0]
        if (statement !is IrReturn) return false
        val value = statement.value

        if (value is IrGetValue) return true

        return false
    }

    private fun isSingleStatementReturnPure(function: IrFunction): Boolean {
        val body = function.body ?: return false
        if (body is IrSyntheticBody) return false // Not sure what this IS, but it has no statements
        if (body.statements.size != 1) return false
        val statement = body.statements[0]
        if (statement !is IrReturn) return false

        val value = statement.value
        if (value is IrConst<*>) return true
        if (value is IrGetValue && !value.symbol.owner.let { it is IrVariable && it.isVar }) return true

        return false
    }
}