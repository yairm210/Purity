@file:OptIn(UnsafeDuringIrConstructionAPI::class)
package yairm210.purity.validation

import org.jetbrains.kotlin.ir.declarations.*
import org.jetbrains.kotlin.ir.expressions.*
import org.jetbrains.kotlin.ir.symbols.UnsafeDuringIrConstructionAPI
import org.jetbrains.kotlin.ir.util.*
import org.jetbrains.kotlin.name.FqName
import yairm210.purity.PurityConfig
import yairm210.purity.validation.wellknown.*

/** Checks the expected purity of a given IrFunction.
 * Unlike [CheckFunctionPurityVisitor] this is not a deep dive into the function.
 * Rather, it checks by annotations, function names, and parent classes. 
 * */
object ExpectedFunctionPurityChecker {

    fun classMatches(function: IrFunction, wellKnownClasses: Set<String>): Boolean {
        val parentClassIdentifier = function.parent.fqNameForIrSerialization.asString()
        return parentClassIdentifier in wellKnownClasses
    }
    
    private val intrinsicConstEvaluationFqName = FqName("kotlin.internal.IntrinsicConstEvaluation")

    /** Tests shallowly whether we should consider the function as pure.
     * Does not check the function body, but rather checks for annotations, function names, and parent classes.
     * */
    fun isMarkedAsPure(function: IrFunction, purityConfig: PurityConfig): Boolean {
        // Marked by @Pure
        if (function.hasAnnotation(Annotations.Pure)) return true // Custom annotation for readonly functions
        
        // Simple values like int + int -> plus(int, int), are marked thus
        val constEvaluation = function.getAnnotation(intrinsicConstEvaluationFqName)
        if (constEvaluation != null) return true

        val fullyQualifiedClassName = function.parent.fqNameForIrSerialization.asString()
        if (fullyQualifiedClassName in wellKnownPureClasses) return true
        if (fullyQualifiedClassName in purityConfig.wellKnownPureClassesFromUser) return true

        val fullyQualifiedFunctionName = function.fqNameForIrSerialization.asString()
        if (fullyQualifiedFunctionName in wellKnownPureFunctions) return true
        if (fullyQualifiedFunctionName in purityConfig.wellKnownPureFunctionsFromUser) return true
        if (wellKnownPureFunctionsPrefixes.any { fullyQualifiedFunctionName.startsWith(it) }) return true

        // autogenerated <get-val> functions for files & classes - allows reading from class.val
        if (function.isGetter
            && !(function as IrSimpleFunction).correspondingPropertySymbol!!.owner.isVar
        ) return true
        
        // Check if we're overriding a marked @Pure function
        if (function is IrSimpleFunction && getAllOverriddenFunctions(function).any { it.hasAnnotation(Annotations.Pure) })
            return true

        if (isSingleStatementReturnPure(function)) return true
        
        if (isAutogeneratedEnumFunction(function)) return true
        
        if (isOfImmutableDataClass(function) && isAutogeneratedDataClassFunction(function)) return true
        
        return false
    }
    
    private val autogeneratedEnumFunctionNames = setOf("values", "valueOf", "compareTo")
    private fun isAutogeneratedEnumFunction(function: IrFunction): Boolean {
        if ((function.parent as? IrClass)?.isEnumClass != true) return false
        return function.name.asString() in autogeneratedEnumFunctionNames
    }
    
    private fun isOfImmutableDataClass(function: IrFunction): Boolean {
        val parentClass = function.parent as? IrClass ?: return false
        if (!parentClass.isData) return false
        return parentClass.properties.none { it.isVar }
    }
    
    fun isOfDataClass(function: IrFunction): Boolean {
        val parentClass = function.parent as? IrClass ?: return false
        return parentClass.isData
    }

    /** Regex for data class componentN functions */
    val componentRegex = "component\\d+".toRegex()
    
    private fun isAutogeneratedDataClassFunction(function: IrFunction): Boolean {
        if (function.name.asString() == "copy") return true // copy function for data classes
        if (function.name.asString().matches(componentRegex)) return true // componentN functions for data classes
        return false
    }

    private fun isAutogeneratedGetter(function: IrFunction): Boolean {
        val body = function.body ?: return false
        val isAutogeneratedFieldAccess =
            body.statements.size == 1
                    && body.statements[0] is IrField
        if (isAutogeneratedFieldAccess) return true
        return false
    }

    fun isReadonly(function: IrFunction, purityConfig: PurityConfig): Boolean {
        if (function.isGetter) return true 
        
        if (function.hasAnnotation(Annotations.Readonly)) return true // Marked by @Readonly

        if (function.name.asString().startsWith("<get-")) return true // Autogenerated function for class variables

        val fullyQualifiedClassName = function.parent.fqNameForIrSerialization.asString()
        if (fullyQualifiedClassName in wellKnownReadonlyClasses) return true
        if (fullyQualifiedClassName in purityConfig.wellKnownReadonlyClassesFromUser) return true

        // Do NOT check for readonly parent classes - child classes can add non-readonly functionality!
        // E.g. List is readonly, but ArrayList is not.

        val fullyQualifiedFunctionName = function.fqNameForIrSerialization.asString()
        if (fullyQualifiedFunctionName in wellKnownReadonlyFunctions) return true
        if (fullyQualifiedFunctionName in purityConfig.wellKnownReadonlyFunctionsFromUser) return true

        // What is a NON-simple function, you ask? So do I! Lazy functions perhaps?
        if (function is IrSimpleFunction) {
            // Check if we're overriding a well-known readonly function
            for (overriddenFunction in getAllOverriddenFunctions(function).toSet()) {
                val overriddenFunctionName = overriddenFunction.fqNameForIrSerialization.asString()
                if (overriddenFunctionName in wellKnownReadonlyFunctions) return true
                if (overriddenFunctionName in purityConfig.wellKnownReadonlyFunctionsFromUser) return true
                if (overriddenFunction.hasAnnotation(Annotations.Readonly)) return true // We're overriding a @Readonly function
            }
        }

        if (isSingleStatementReturnReadonly(function)) return true

        // Data class destructuring functions
        if (isOfDataClass(function) && isAutogeneratedDataClassFunction(function)) return true

        return false
    }

    /** For convenience - single-declaration functions like "fun getX() = x" are readonly */
    private fun isSingleStatementReturnReadonly(function: IrFunction): Boolean {
        val body = function.body ?: return false
        if (body is IrSyntheticBody) return false // Not sure what this IS, but it has no statements
        if (body.statements.size != 1) return false
        val statement = body.statements[0]
        if (statement !is IrReturn) return false
        val value = statement.value

        if (value is IrGetValue) return true // function local variable access
        
        // getter for a field e.g. this.varvar
        if (value is IrCall && value.symbol.owner.isGetter // <something>.property
            && value.dispatchReceiver is IrGetValue  // <something> is a function local variable
         ) return true

        return false
    }

    private fun isSingleStatementReturnPure(function: IrFunction): Boolean {
        val body = function.body ?: return false
        if (body is IrSyntheticBody) return false // Not sure what this IS, but it has no statements
        if (body.statements.size != 1) return false
        val statement = body.statements[0]
        if (statement !is IrReturn) return false

        val value = statement.value
        if (value is IrConst<*>) return true
        if (value is IrGetValue && !value.symbol.owner.let { it is IrVariable && it.isVar }) return true
        
        if (value is IrCall && value.symbol.owner.isGetter && // <something>.property 
            value.dispatchReceiver is IrGetValue  // <something> is a function-local value, not variable
                && !(value.dispatchReceiver as IrGetValue).symbol.owner.let { it is IrVariable && it.isVar }
                && value.symbol.owner.correspondingPropertySymbol?.owner?.isVar == false) return true

        return false
    }
}

// overriddenSymbols only gives you the *direct* overrides, not the transitive ones.
internal fun getAllOverriddenFunctions(function: IrSimpleFunction): Sequence<IrSimpleFunction> {
    return function.overriddenSymbols.asSequence()
        .flatMap {
            val owner = it.owner
            sequenceOf(owner) + getAllOverriddenFunctions(owner)
        }
}
