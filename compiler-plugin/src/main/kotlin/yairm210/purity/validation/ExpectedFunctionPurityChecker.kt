@file:OptIn(UnsafeDuringIrConstructionAPI::class)
package yairm210.purity.validation

import org.jetbrains.kotlin.ir.declarations.*
import org.jetbrains.kotlin.ir.expressions.*
import org.jetbrains.kotlin.ir.symbols.UnsafeDuringIrConstructionAPI
import org.jetbrains.kotlin.ir.util.*
import org.jetbrains.kotlin.name.FqName
import yairm210.purity.PurityConfig

/** Checks the expected purity of a given IrFunction.
 * Unlike [CheckFunctionPurityVisitor] this is not a deep dive into the function.
 * Rather, it checks by annotations, function names, and parent classes. 
 * */
object ExpectedFunctionPurityChecker {

    fun classMatches(function: IrFunction, wellKnownClasses: Set<String>): Boolean {
        val parentClassIdentifier = function.parent.fqNameForIrSerialization.asString()
        return parentClassIdentifier in wellKnownClasses
    }
    
    private val pureAnnotationFqName = FqName("yairm210.purity.annotations.Pure")
    private val intrinsicConstEvaluationFqName = FqName("kotlin.internal.IntrinsicConstEvaluation")
    private val readonlyAnnotationFqName = FqName("yairm210.purity.annotations.Readonly")

    fun isMarkedAsPure(function: IrFunction, purityConfig: PurityConfig): Boolean {
        // Marked by @Pure
        if (function.hasAnnotation(pureAnnotationFqName)) return true // Custom annotation for readonly functions
        
        // Simple values like int + int -> plus(int, int), are marked thus
        val constEvaluation = function.getAnnotation(intrinsicConstEvaluationFqName)
        if (constEvaluation != null) return true

        val fullyQualifiedClassName = function.parent.fqNameForIrSerialization.asString()
        if (fullyQualifiedClassName in wellKnownPureClasses) return true
        if (fullyQualifiedClassName in purityConfig.wellKnownPureClassesFromUser) return true

        val fullyQualifiedFunctionName = function.fqNameForIrSerialization.asString()
        if (fullyQualifiedFunctionName in wellKnownPureFunctions) return true
        if (fullyQualifiedFunctionName in purityConfig.wellKnownPureFunctionsFromUser) return true
        if (wellKnownPureFunctionsPrefixes.any { fullyQualifiedFunctionName.startsWith(it) }) return true

        // autogenerated <get-val> functions for files & classes - allows reading from class.val
        if (function.isPropertyAccessor
            && !(function as IrSimpleFunction).correspondingPropertySymbol!!.owner.isVar
        ) return true
        
        // Check if we're overriding a marked @Pure function
        if (function is IrSimpleFunction && getAllOverriddenFunctions(function).any { it.hasAnnotation(pureAnnotationFqName) })
            return true

        if (isSingleStatementReturnPure(function)) return true
        
        // autogenerated enum comparison
        if ((function.parent as? IrClass)?.isEnumClass == true && function.name.asString() == "compareTo") return true

        return false
    }


    fun isReadonly(function: IrFunction, purityConfig: PurityConfig): Boolean {
        // Marked by @Readonly
        if (function.hasAnnotation(FqName("yairm210.purity.annotations.Readonly"))) return true // Custom annotation for readonly functions

        if (function.name.asString().startsWith("<get-")) return true // Autogenerated function for class variables

        val fullyQualifiedClassName = function.parent.fqNameForIrSerialization.asString()
        if (fullyQualifiedClassName in wellKnownReadonlyClasses) return true
        // TODO: Do we need user-inputted readonly classes?

        // Do NOT check for readonly parent classes - child classes can add non-readonly functionality!
        // E.g. List is readonly, but ArrayList is not.

        val fullyQualifiedFunctionName = function.fqNameForIrSerialization.asString()
        if (fullyQualifiedFunctionName in wellKnownReadonlyFunctions) return true
        if (fullyQualifiedFunctionName in purityConfig.wellKnownReadonlyFunctionsFromUser) return true
        
        if (isWellKnownIterableOrSequenceFunction(fullyQualifiedFunctionName)) return true

        // What is a NON-simple function, you ask? So do I! Lazy functions perhaps?
        if (function is IrSimpleFunction) {
            // Check if we're overriding a well-known readonly function
            for (overriddenFunction in getAllOverriddenFunctions(function).toSet()) {
                val overriddenFunctionName = overriddenFunction.fqNameForIrSerialization.asString()
                if (overriddenFunctionName in wellKnownReadonlyFunctions) return true
                if (overriddenFunctionName in purityConfig.wellKnownReadonlyFunctionsFromUser) return true
                if (overriddenFunction.hasAnnotation(readonlyAnnotationFqName)) return true // We're overriding a @Readonly function
            }
        }

        if (isSingleStatementReturnReadonly(function)) return true

        if (function.isGetter) return true

        return false
    }

    // overriddenSymbols only gives you the *direct* overrides, not the transitive ones.
    private fun getAllOverriddenFunctions(function: IrSimpleFunction): Sequence<IrSimpleFunction> {
        return function.overriddenSymbols.asSequence()
            .flatMap {
                val owner = it.owner
                sequenceOf(owner) + getAllOverriddenFunctions(owner)
            }
    }

    /** For convenience - single-declaration functions like "fun getX() = x" are readonly */
    private fun isSingleStatementReturnReadonly(function: IrFunction): Boolean {
        val body = function.body ?: return false
        if (body is IrSyntheticBody) return false // Not sure what this IS, but it has no statements
        if (body.statements.size != 1) return false
        val statement = body.statements[0]
        if (statement !is IrReturn) return false
        val value = statement.value

        if (value is IrGetValue) return true // function local variable access
        
        // getter for a field e.g. this.varvar
        if (value is IrCall && value.symbol.owner.isGetter // <something>.property
            && value.dispatchReceiver is IrGetValue  // <something> is a function local variable
         ) return true

        return false
    }

    private fun isSingleStatementReturnPure(function: IrFunction): Boolean {
        val body = function.body ?: return false
        if (body is IrSyntheticBody) return false // Not sure what this IS, but it has no statements
        if (body.statements.size != 1) return false
        val statement = body.statements[0]
        if (statement !is IrReturn) return false

        val value = statement.value
        if (value is IrConst<*>) return true
        if (value is IrGetValue && !value.symbol.owner.let { it is IrVariable && it.isVar }) return true
        
        if (value is IrCall && value.symbol.owner.isGetter && // <something>.property 
            value.dispatchReceiver is IrGetValue  // <something> is a function-local value, not variable
                && !(value.dispatchReceiver as IrGetValue).symbol.owner.let { it is IrVariable && it.isVar }
                && value.symbol.owner.correspondingPropertySymbol?.owner?.isVar == false) return true

        return false
    }
}