{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":""},{"location":"#what-is-this","title":"What is this?","text":"<p>A Kotlin Compiler Plugin for determining and enforcing Pure and Readonly functions.</p> <p>Tested with Kotlin versions 1.4.0 - 2.2.20</p>"},{"location":"#why","title":"Why?","text":"<ul> <li>Communicating and enforcing function intent</li> <li>Determining parallelizable calls (Pure functions are parallelizable with anything; Readonly are parallelizable with each other)</li> </ul>"},{"location":"#installation-basic-usage","title":"Installation + Basic Usage","text":"<p>Install the plugin by adding the following to your <code>build.gradle.kts</code>:</p> <pre><code>plugins {\n    id(\"io.github.yairm210.purity-plugin\") version \"1.3.0\"\n}\n\ndependencies {\n  implementation(\"io.github.yairm210:purity-annotations:1.3.0\")\n}\n</code></pre> <p>Mark pure functions using <code>@Pure</code>, and readonly functions using <code>@Readonly</code>:</p> <pre><code>import yairm210.purity.annotations.Pure\nimport yairm210.purity.annotations.Readonly\n@Pure\nfun pureFunction(x: Int): Int {\n    return x * 2\n}\n@Readonly\nfun readonlyFunction(list: List&lt;String&gt;): Int {\n    return list.size\n}\n</code></pre>"},{"location":"#rules","title":"Rules","text":"<ul> <li> <p>Pure functions may not:</p> <ul> <li>Get or set external vars (vars created outside the function)</li> <li>Call other non-pure functions</li> </ul> </li> <li> <p>Readonly functions may not:</p> <ul> <li>Set external vars</li> <li>Call other non-readonly functions (pure functions are considered readonly as well)</li> </ul> </li> </ul> <p>Any violation of these rules creates a compilation error.</p>"},{"location":"#suppressing-validity-checks","title":"Suppressing validity checks","text":"<p>Every dependency tree has leaves at the bottom.</p> <p>In order to gradually build up the functions that are checked by the compiler, you may want to work top-down, marking functions as you go.</p> <p>You can stop the process from here on by marking a function with <code>@Suppress(\"purity\")</code>, like so:</p> <pre><code>var external = 3\n// reads an external variable, but will not throw a compilation error\n@Pure @Suppress(\"purity\")\nfun actsAsPure(): Int {\n    return external\n}\n</code></pre>"},{"location":"#limitations","title":"Limitations","text":"<ul> <li>All getters are assumed to not be state-changing</li> <li>All constructors are assumed to be pure - to change state only of the instance being created</li> </ul>"},{"location":"development/development/","title":"Development","text":""},{"location":"development/development/#development","title":"Development","text":""},{"location":"development/development/#testing","title":"Testing","text":"<p>To test the plugin on /lib, run <code>./gradlew :lib:clean :lib:build</code> - the plugin is only active when the build cache is changed</p> <p>JvmSampleTests.kt is not a standard test suite - it succeeds if it compiles. However, it is still divided into the various test cases, which are all standalone.</p> <p>To debug, you can run gradle lib:build via IntelliJ to debug the actual compiler plugin. (Need to click f9 4 times on gradle, not sure how to fix)</p> <p>To test on other projects, first increment the version (see below) - otherwise the plugin from the gradle plugin repository will be used.</p>"},{"location":"development/development/#publishing-locally-for-use-in-local-projects","title":"Publishing locally for use in local projects","text":"<p>To publish the compiler plugin locally:</p> <ul> <li>Comment out the <code>signAllPublications()</code> line in <code>compiler-plugin/build.gradle.kts</code> if you don't have the signing keys set up</li> <li><code>./gradlew :compiler-plugin:publishToMavenLocal</code></li> <li>It should now be available in <code>~/.m2/repository/io/github/yairm210/compiler-compiler-plugin/&lt;version&gt;</code></li> </ul> <p>To publish the gradle plugin locally:</p> <ul> <li><code>./gradlew :gradle-plugin:build</code></li> <li>It should now be available in <code>~/.m2/repository/io/github/yairm210/gradle-plugin/&lt;version&gt;</code></li> </ul> <p>To use the local plugin in another local project, add to <code>build.gradle.kts</code>:</p> <pre><code>plugins {\n    id(\"io.github.yairm210.purity-plugin\") version \"&lt;version&gt;\" // Require the gradle plugin\n}\nrepositories {\n    mavenLocal() // To get the compiler plugin locally\n}\n</code></pre> <p>And add to <code>settings.gradle.kts</code>:</p> <pre><code>pluginManagement {\n    repositories {\n        mavenLocal() // To get the compiler plugin locally\n        gradlePluginPortal() // So other plugins can be resolved\n    }\n}\n</code></pre>"},{"location":"development/development/#project-structure","title":"Project Structure","text":"<ul> <li>lib - A Kotlin Multiplatform project which applies a gradle plugin (compiler.plugin.helloworld) which triggers the compiler plugin.</li> <li>compiler-plugin - This module contains the Kotlin Compiler Plugin</li> <li>gradle-plugin - This module contains the gradle plugin which trigger the compiler plugin</li> </ul>"},{"location":"development/development/#versioning","title":"Versioning","text":"<p>Gradle plugins used in other projects must be included in settings.gradle.kts as 'includeBuild', so they'll be available as a plugin.</p> <p>This unfortunately precludes them from depending on buildSrc for a single source of truth for the version. Thus, the version must be updated in multiple places:</p> <ul> <li>Update version in compiler plugin - <code>compiler-plugin/build.gradle.kts</code></li> <li>Update version in gradle plugin - <code>PurityGradlePlugin.kt</code></li> <li>Update version in <code>gradle-plugin/build.gradle.kts</code></li> </ul>"},{"location":"development/kotlin-ir-documentation/","title":"Kotlin ir documentation","text":""},{"location":"development/kotlin-ir-documentation/#kotlin-ir-documentation","title":"Kotlin IR Documentation","text":"<p>Kotlin IR is virtually undocumented, so here are some notes</p>"},{"location":"development/kotlin-ir-documentation/#irfunction","title":"IrFunction","text":"<p>Represents a function, either declared in your code - in which case it has a body of declarations - or declared externally.</p> <p>In either case, what you do know about it is the input and output types.</p>"},{"location":"development/kotlin-ir-documentation/#irdeclaration","title":"IrDeclaration","text":"<p>A 'line of code' - can be a function call, setting a variable, an if statement, etc.</p>"},{"location":"development/kotlin-ir-documentation/#irexpression","title":"IrExpression","text":"<p>This is 'anything that returns a value'. Some prime examples are:</p> <ul> <li><code>IrCall</code> - a function call</li> <li><code>IrConst</code> - a hardcoded const value - e.g. <code>1</code>, <code>\"hi\"</code>, <code>false</code></li> <li><code>IrGetValue</code> - a local variable</li> </ul>"},{"location":"development/kotlin-ir-documentation/#ircall","title":"IrCall","text":"<p>An <code>IrExpression</code> representing a function call - x() or a.x().</p> <p><code>irCall.symbol.owner</code> gets you to the IrFunction.</p> <p>When the function is part of a class (a.x()), <code>irCall.dispatchReceiver</code> lets you retrieve the IrExpression to the left of the dot - in this case <code>a</code>.</p> <p>When it's an extension function, the same applies to <code>irCall.extensionReceiver</code>.</p>"},{"location":"development/kotlin-ir-documentation/#irgetvalue","title":"IrGetValue","text":"<p>An <code>IrExpression</code> that retrieves the value of a local variable, which can be val or var.</p> <p>To find out about the actual val/var being referenced, you need to check <code>irGetValue.symbol.owner</code> which is a <code>IrValueDeclaration</code>.</p> <p>For example, <code>irValueDeclaration.isVar</code> indicates mutability.</p>"},{"location":"development/kotlin-ir-documentation/#irproperty","title":"IrProperty","text":"<p>Unlike local variables, all class properties are represented by <code>IrProperty</code>, which generates behind the scenes:</p> <ul> <li>An <code>IrField</code> for the backing field</li> <li>a getter <code>IrFunction</code></li> <li>a setter <code>IrFunction</code> (for <code>var</code> properties)</li> </ul> <p>This means all access to properties is through the getter/setter functions (<code>IrCall</code>) and not through <code>IrGetValue</code></p>"},{"location":"development/principles/","title":"Development Principles","text":""},{"location":"development/principles/#minimum-user-interface","title":"Minimum user interface","text":"<p>Ideally, users should only need to add <code>@Pure</code> and <code>@Readonly</code> to functions. Everything else should be determined automatically.</p> <p>In practice, this is not possible, and thus 'escape hatches' - like <code>@LocalState</code> and <code>@Immutable</code> - are needed.  We strive to provide users with enough options that they don't need to change their existing code to accomodate purity checking,  and to provide enough automation they only need the escape hatches in cases we cannot statically determine purity.</p>"},{"location":"development/principles/#everything-is-configurable","title":"Everything is configurable","text":"<p>We have many long lists of \"well known\" things - pure and readonly classes and types, local-state classes, etc.</p> <p>Each of these should have 3 possible sources:</p> <ul> <li>Configurations for Java and Kotlin standard libraries should be in well-known hardcoded lists in the compiler plugin</li> <li>Configuration for external libraries should be possible via the plugin configuration in Gradle</li> <li>Configuration for the code being checked should be addable via annotations on the code itself </li> </ul>"},{"location":"usage/advanced-usage/","title":"Advanced usage","text":""},{"location":"usage/advanced-usage/#advanced-usage","title":"Advanced Usage","text":""},{"location":"usage/advanced-usage/#marking-variables-as-immutable","title":"Marking variables as Immutable","text":"<p>Many helpful functions, especially on collections, are readonly - because the function itself is the same regardless of the list it's iterating.</p> <p>These functions are however deterministic - so when run on an immutable value, they will always return the same result, i.e. are Pure.</p> <p>You can mark vals as Immutable to allow recognizing readonly functions run on them, as pure:</p> <pre><code>@Immutable\nval immutableMap = mapOf(1 to 2, 3 to 4)\n\n@Pure\nfun pureFunction(int: Int): Int {\n    return immutableMap[int] ?: 0\n}\n</code></pre>"},{"location":"usage/advanced-usage/#local-state-variables","title":"Local State variables","text":"<p>Function purity is determined by its outer boundary - given the same call, return the same result. How we generate that result is up to us</p> <p>One way many functions work is by building up a mutable object - a list, a map, etc - and returning it.</p> <p>Common classes we can recognize as \"holding internal state\", and thus new instances can be recognized as \"only available within the function\". New classes can be added via <code>wellKnownInternalStateClasses</code> in the config. </p> <p>For non-constructors, we need to add the <code>@LocalState</code> attribute manually:</p> <pre><code>@Pure fun getArrayList(): ArrayList&lt;String&gt; = ArrayList&lt;String&gt;().apply {\n    add(\"string\")\n}\n\n@Pure\nfun alterExternallyDeclaredInnerStateClass() {\n  @LocalState val newArrayList = getArrayList()\n  newArrayList.add(\"another string\") // Anything is allowed on a LocalState variable\n}\n</code></pre> <p>Unfortunately, since it's only functions on the val itself that are allowed, we cannot chain calls. The best be can do is assign the value back to a variable and then use it.</p> <p>Note that adding <code>@LocalState</code> is a promise by the developer, and is abusable. Consider the following abuse example:</p> <pre><code>val existingArrayList = ArrayList&lt;String&gt;()\n\n@Pure\nfun alterExternallyDeclaredInnerStateClass() {\n  @LocalState // False, and leads to broken contract!\n  val localArrayList = existingArrayList // val access is allowed\n  localArrayList.add(\"string\") // Anything is allowed on a LocalState variable\n}\n</code></pre>"},{"location":"usage/advanced-usage/#caching","title":"Caching","text":"<p>Often, you want to cache the result of a function in a class property - this is technically a state-altering operation, but the function as called could still be pure.</p> <p>You can mark these with @Cache to indicate that mutating functions, and setting, can be used on them.</p> <p>These properties must be private to ensure they cannot be mutated by external code.</p> <p>Note that for mutating caches (like maps), this does not guarantee thread safety, so use thread-safe data structures for multithreading.</p> <pre><code>@Cache private val cacheMap: MutableMap&lt;Int, Int&gt; = mutableMapOf()\nfun cachedMutatingFunction(input: Int): Int {\n    return cacheMap.getOrPut(input){ input * 2 }\n}\n\n@Cache private var value = 0\nfun cachedSettingFunction(): Int {\n    if (value == 0) value = 42 // \"heavy processing function\"\n    return value\n}\n</code></pre>"},{"location":"usage/advanced-usage/#autorecognized-functions","title":"Autorecognized functions","text":"<p>Some functions are simple enough that they don't even need to be marked.</p> <ul> <li>functions that return a const are recognized as Pure (<code>fun getNum() = 42</code>)</li> <li>functions that return a property of this class (<code>fun getThing() = innerThing</code>) are recognized as Readonly if var, and Pure if val</li> </ul>"},{"location":"usage/advanced-usage/#inheritance","title":"Inheritance","text":"<p>Functions that override other functions, or implement interfaces, are automatically recognized as at least as strict as the overridden function.</p> <pre><code>interface AreaCalculator {\n  @Pure\n  fun area(): Int\n}\n\nclass Square(val width: Int) : AreaCalculator {\n  override fun area(): Int = width * width  // Checked as if the function is marked with @Pure\n\n  @Pure\n  fun otherFunction(): Int = area() // Can call area() since it is considered @Pure\n}\n</code></pre>"},{"location":"usage/advanced-usage/#functions-as-parameters","title":"Functions as parameters","text":"<p>Trick question: What purity is .let{}? The answer is: It depends on the function passed to it. Since we wish to allow passing pure functions to it, we recognize it as Pure.</p> <p>The same is true for all other functions that take a function as a parameter - we allow invoking passed functions, without their purity affecting the purity of the function that takes them.</p> <p>The reasoning is thus: The function that calls this function, if marked as Pure, cannot contain non-Pure code; If readonly, cannot contain non-Readonly code. Thus the called function takes on - at the least - the purity of the caller.</p> <p>However, there are situations where you want to enforce the purity of a passed function. You can do so by marking the parameter as @Pure or @Readonly:</p> <pre><code>@Readonly\nfun invoker(@Readonly function: (String) -&gt; Unit) {\n    function(\"world\") \n}\n\n// We sent a non-readonly function, so this should fail\nfun compilationErrorInvokeWithNonReadonly() {  \n    invoker { i:String -&gt; println(\"Hello, $i!\") } // will fail compliation - non-Readonly function passed to a Readonly function parameter\n}\n</code></pre>"},{"location":"usage/advanced-usage/#calling-subfunctions","title":"Calling subfunctions","text":"<p>Subfunctions - functions created within the function scope - may be called even without being explicitly marked - since their contents are checked as part of the larger function.</p> <p>This allows us to use subfunctions that write to local variables, while retaining the purity of the overall function:</p> <pre><code> @Pure \n    fun functionTested(): Int {\n        var internal = 0\n        fun subFunction() { internal += 1 }\n        subFunction()\n        return internal\n    }\n</code></pre>"},{"location":"usage/configuration/","title":"Configuration","text":""},{"location":"usage/configuration/#configuration","title":"Configuration","text":""},{"location":"usage/configuration/#disable-validation","title":"Disable validation","text":"<p>To disable all checks, either by some computed condition or just globally:</p> <pre><code>import yairm210.purity.PurityConfiguration // at the top of your build.gradle.kts\n\nconfigure&lt;PurityConfiguration&gt; {\n    enabled = false\n}\n</code></pre> <p>This is a cheap way to validate that the plugin is not the cause of compilation or latency problems.</p>"},{"location":"usage/configuration/#handling-external-libraries","title":"Handling external libraries","text":"<p>To support idiomatic Kotlin, Purity already recognizes pure and readonly functions of well-known classes in Kotlin and Java.</p> <p>You can expand this to include external libraries in the following way:</p> <pre><code>import yairm210.purity.PurityConfiguration // at the top of your build.gradle.kts\n\nconfigure&lt;PurityConfiguration&gt; { // All of these are examples that are already contained in the known functions/classes \n  wellKnownPureClasses = setOf(\"kotlin.ranges.IntRange\")\n  wellKnownPureFunctions = setOf(\"kotlin.collections.listOf\")\n  wellKnownReadonlyClasses = setOf(\"kotlin.sequences.Sequence\")\n  wellKnownReadonlyFunctions = setOf(\"java.util.EnumMap.get\")\n  wellKnownInternalStateClasses = setOf(\"java.util.LinkedHashSet\") // classes that mutate no state but their own\n}\n</code></pre>"},{"location":"usage/configuration/#warn-where-annotations-can-be-added","title":"Warn where annotations can be added","text":"<p>By default, Purity only checks that functions are at least as strict as declared. Once most of the code has been annotated, you may wish to see what other functions are strict enough to accept annotations, to 'lock them in' to their current purity level.</p> <pre><code>import yairm210.purity.PurityConfiguration // at the top of your build.gradle.kts\n\nconfigure&lt;PurityConfiguration&gt; { \n  warnOnPossibleAnnotations = true\n}\n</code></pre>"}]}